---
title: "CopyNumber Colibactin Clones - recalling of segments and gene annotation"
author: "Hilmar Berger"
output:
 html_document:
    toc: true
    toc_depth: 3
    toc_float: false
    number_sections: true
    code_folding: hide
    
pdf_document:
    fig_caption: true
date: "`r format(Sys.time(), '%d %B, %Y %H:%M:%S')`"
---

```{r, message=FALSE}
rm(list=ls())
library(naturalsort)
suppressMessages(library(GenomicRanges))
library(GenomicFeatures)
library(reshape2)
library(DNAcopy)
library(RColorBrewer)
library(ggplot2)
library(modeest)
library(pheatmap)
library(data.table)

result_folder = "../../../Results/DNASeq"
if (!file.exists(result_folder)) dir.create(result_folder, recursive=T)
```

# Introduction

We take coverage based log ratios as determined from Exome sequences of pooled samples or clones compared to the pooled uninfected sample of the same mouse. Since the normalization of the distributions seems to be unstable and showed biase in several samples, we determine the mode of log ratios for each sample using the Venter method from R package *modeest* and then segment re-normalized log ratios using Circular Binary Segmentation as implemented in the Bioconductor package DNAcopy. We finally annotate aberrant segments with overlapping genes.


```{r}
call_cn_segments = function(data) {
  all_chroms = list()
  sample_mode = mlv(data$Adjusted.Mean.of.LogRatio, method="Venter")$M
  for ( c in c(as.character(1:19), "X", "Y") ) {
    c_chrom = paste("chr",c,sep="")  
    tmp = subset(data, Chr == c_chrom)
    if (nrow(tmp)==0) next
    cna.dat <- CNA(tmp$Adjusted.Mean.of.LogRatio-sample_mode, tmp$Chr, tmp$OriStCoordinate, data.type="logratio")
    smooth.cna.dat = smooth.CNA(cna.dat)
    cna.segment = segment(smooth.cna.dat, verbose = F, undo.splits = "prune")
    all_chroms[[c]] = cna.segment$output
  }
  all_segs = do.call(rbind, all_chroms)
}
```



```{r}
reload_data = F

input_folder = "../../../Data/Processed/DNA_Variants_Contra/"

samples =  c(paste("2702_",c("B","C","D","E","F","G","H"), sep=""), paste("3466_",c("B","C","D","E","F","G","H"), sep=""))

input_Rdata_file = file.path(input_folder, "CNV_ratios_all_samples.Rdata")

if(reload_data) {
  
  all_CN_res = list()
  for(s in samples) {
    inp_file = paste("CN_",s,"/table/CNATable.10rd.10bases.20bins.txt", sep="")
    tmp = read.table(file.path(input_folder, inp_file), sep="\t", header=T)
    tt = naturalsort(names(table(tmp$Chr)))
    chrom_sorted = 1:length(tt)
    names(chrom_sorted) = tt
    tmp$chromorder = chrom_sorted[as.character(tmp$Chr)]
    tmp = tmp[order(tmp$chromorder, tmp$OriStCoordinate), ]
    all_CN_res[[s]] = tmp
  }
  
  save(all_CN_res, file=input_Rdata_file)  
} else {
  load(input_Rdata_file)
}

```


```{r}
long_calls_Rdata = file.path(input_folder, "Long_CNV_recalled.Rdata")
if(reload_data) {
  all_long_CN_calls = list()
  for(s in samples) {
    segs = call_cn_segments(all_CN_res[[s]])
    segs$sample = s
    all_long_CN_calls[[s]] = segs
  }
  
  save(all_long_CN_calls, file=long_calls_Rdata )
} else {
  load(long_calls_Rdata )
}
```


# Genome Overview

## Global distributions

We observed biases in the modes of Log2Ratios in WI-samples of Mouse3 that cannot be explained by differences in coverage. Most likely those are due to the presence of several large genomic losses that bias the median normalization. Using the mode instead of the median to normalize those distributions improves the estimates. 

```{r}
sample_modes = unlist(lapply(all_CN_res, function(x) mlv(x$Adjusted.Mean.of.LogRatio, method="Venter")$M))

barplot(sample_modes, las=2, ylab="Mode (Venter)", main="Sample Modes of LogRatios as generated by CONTRA")
```

```{r, fig.width=14, fig.height=8}
first = T
cols = rep_len(brewer.pal(n=12, "Set3"), 14)
names(cols) = names(all_CN_res)

for (n in names(all_CN_res)) {
  if(first) {
    first=F
    plot(density(all_CN_res[[n]]$Adjusted.Mean.of.LogRatio), col=cols[n], ylim=c(0,1.2), main="Log2Ratio distribution per sample", lwd=4)
  } else {
    lines(density(all_CN_res[[n]]$Adjusted.Mean.of.LogRatio), col=cols[n], lwd=4)
  }
}
legend("topleft", legend=names(all_CN_res), fill=cols)

```



## Log2Ratios by sample and chromosome

```{r}
palette(brewer.pal(8, "Set2"))
```


```{r, fig.width=12, fig.heigth=8}
tt = naturalsort(unique(unlist(lapply(all_CN_res, function(x) x$Chr))) )
chrom_sorted = 1:length(tt)
names(chrom_sorted) = tt

for (s in samples) {
  chr = unique(all_CN_res[[s]]$Chr)
  plot(runmed(all_CN_res[[s]]$Adjusted.Mean.of.LogRatio-sample_modes[s],21), pch=20, ylim=c(-7, 7), ylab="log ratio sample vs. control, running median, k=21", main = paste(s, "vs. Control"), col=chrom_sorted[as.character(all_CN_res[[s]]$Chr)])
  abline(h=c(-1, 0, 1))
  legend("topleft", legend=chr, fill=1:length(chr), cex=0.7)
}
```



```{r}
suppressMessages(library(GenomicRanges))
suppressMessages(library(GenomicFeatures))
normal_chroms = c(as.character(1:19),"X","Y")

update_fun = function(x,n) {x$Chr = gsub("chr","", x$Chr); x$sample=n; x$log2ratio_norm = x$Adjusted.Mean.of.LogRatio - sample_modes[n]; return(x) }

tmp = do.call(rbind, mapply(update_fun, all_CN_res, names(all_CN_res), SIMPLIFY = FALSE) )

dd = as.data.table(subset(tmp, Chr %in% normal_chroms))
dd$chromorder = factor(dd$Chr, levels=naturalsort(names(table(dd$Chr))))
setorder(dd, sample, chromorder, OriStCoordinate)

cnv_ratio_ranges = GRanges(dd$chromorder, ranges=IRanges(dd$OriStCoordinate, dd$OriEndCoordinate), sample = dd$sample, logratio=dd$Adjusted.Mean.of.LogRatio, logratio_norm = dd$log2ratio_norm, log_level_class = ifelse(dd$log2ratio_norm > 0.5, "gain", ifelse(dd$log2ratio_norm < -0.5, "loss","normal")) )

cnv_ratio_ranges$cnv_color = ifelse(cnv_ratio_ranges$log_level_class=="normal","grey", ifelse(cnv_ratio_ranges$log_level_class=="gain","red","blue") )

cnv_ratio_ranges$logratio_norm_rmed = runmed(cnv_ratio_ranges$logratio_norm, 11)

cnv_ratio_ranges$mouseID = factor(ifelse(substr(cnv_ratio_ranges$sample, 1, 4)=="2702", "Mouse 2", "Mouse 3"))
cnv_ratio_ranges$sampleID_v2 = factor(substr(cnv_ratio_ranges$sample, nchar(cnv_ratio_ranges$sample), nchar(cnv_ratio_ranges$sample)))
```



```{r, echo=FALSE, fig.width=18, fig.height=12}
suppressMessages(library(ggbio))
```

```{r}
track_names = rep(LETTERS[1:7], 2)
names(track_names) = samples

cnv_ratio_ranges$sampleID_publication = track_names[cnv_ratio_ranges$sample]
```


```{r, echo=FALSE, fig.width=12, fig.height=12}
plotGrandLinear(cnv_ratio_ranges,aes(y=logratio_norm_rmed, fill=cnv_color), spaceline=T ) +
  facet_grid(sampleID_publication ~ mouseID) + 
  coord_cartesian(ylim = c(-3, 3)) + 
  theme(text=element_text(size=20), axis.text.x = element_text(angle = 90, hjust = 1)) + 
  geom_hline(yintercept = c(-1,1), linetype="dashed") + 
  geom_hline(yintercept = 0, col="red") + 
  ylab("Running median (k=11) of CN Log2 ratio")

```

## CN ratio heatmap

Here we show genomewide profiles as a heatmap where red colors denote genomic gains and blue colors  hetero- or homozygous genomic losses. Data is ordered top-down by chromosome and genomic position within chromosomes. Please note that small segments might be hard to spot. 

```{r}
chrom_info = read.table("./GRCm38.genome",sep="\t",header=F, stringsAsFactors = F)
chrom_info = subset(chrom_info, V1 %in% c(as.character(1:19),"X","Y"))
chrom_info = chrom_info[naturalorder(chrom_info$V1),]

seq_lengths = chrom_info$V2
names(seq_lengths) = chrom_info$V1
tiles = unlist(tileGenome(seqlengths = seq_lengths, tilewidth = 1e5, cut.last.tile.in.chrom = T))

tiles_with_CN_calls = list()

for (n in names(all_long_CN_calls)) {
  curr_sample = tiles
  curr_cnv = with(all_long_CN_calls[[n]], GRanges(gsub("chr","",chrom), IRanges(loc.start, loc.end), log2ratio=seg.mean))
  ovlp = findOverlaps(curr_cnv, tiles)
  curr_sample$Log2Ratio = 0
  curr_sample$Log2Ratio[subjectHits(ovlp)] = curr_cnv[queryHits(ovlp)]$log2ratio
  tiles_with_CN_calls[[n]] = curr_sample
}


```

```{r, fig.width=14, fig.height=14}
RedBlackBlue = c("red","darkred","black","darkblue","blue")
RedBlackBluePal = colorRampPalette(rev(RedBlackBlue))(100)

tmp_chr = seqnames( tiles_with_CN_calls[[1]] )
tmp_pos = start(tiles_with_CN_calls[[1]])
tmp_id = paste(tmp_chr, tmp_pos, sep="_")

row_anno = data.frame(chromosome=tmp_chr, row.names = tmp_id)

cm = do.call(cbind, lapply(tiles_with_CN_calls, function(x) x$Log2Ratio))
rownames(cm) = tmp_id

new_breaks = c(-6,-1.05,seq(-0.5,0.5,1/96),1.05,6)
pheatmap(cm, cluster_rows = F, cluster_cols = F, scale="none", breaks=new_breaks, color = RedBlackBluePal, annotation_row = row_anno, show_rownames = F)
```



# Genes in aberrant regions

```{r}
M17db = loadDb("../../../Data/External/GencodeM17/GENCODE_basic_M17_TxDB.db")
tx_anno = fread("../../../Data/External/GencodeM17/gencode.vM17.transcript.anno.txt", sep="\t", header=T, stringsAsFactors = F)

# M12db = loadDb("../../../Data/External/GencodeM12/GENCODE_basic_M12_TxDB.db")
# tx_anno = fread("../../../Data/External/GencodeM12/gencode.vM12.transcript.anno.txt", sep="\t", header=T, stringsAsFactors = F)

setkey(tx_anno, transcript)

# combine all samples
all_long_CN_calls_dt = as.data.table(do.call(rbind, all_long_CN_calls))
# exclude all segments with absolute log2ratio for the segment less than 0.3
all_long_CN_calls_dt = subset(all_long_CN_calls_dt, abs(seg.mean) > 0.3)
# classify segments in gain and loss 
all_long_CN_calls_dt$call = ifelse(all_long_CN_calls_dt$seg.mean> 0, "gain", "loss")
# Note that the variant ID which we assign here is not guaranteed to be unique; CNVs in different samples can have the same ID
all_long_CN_calls_dt[, varID:= paste(chrom,":", loc.start,"_", loc.end, sep="") ]
setkey(all_long_CN_calls_dt, "varID")

long_CN_ranges = with(all_long_CN_calls_dt, GRanges(gsub("chr","",chrom), IRanges(loc.start, loc.end), sample=sample, call=call, ID=varID) )
```

```{r}
tx_ranges = transcripts(M17db)
# check overlap of CNV segments with transcripts
ovlp = findOverlaps(long_CN_ranges,tx_ranges)

tx_by_cnv = tapply(tx_ranges[subjectHits(ovlp)]$tx_name, long_CN_ranges[queryHits(ovlp)]$ID, list)
tx_start_by_cnv = tapply(start(tx_ranges[subjectHits(ovlp)]), long_CN_ranges[queryHits(ovlp)]$ID, list)

# Collect all transcripts, genes and their starts overlapped by each CNV
all_long_CN_calls_dt[,tx_names := vector("list", nrow(all_long_CN_calls_dt))]
all_long_CN_calls_dt[,tx_names:= tx_by_cnv[varID]]

all_long_CN_calls_dt[,genes:= lapply(tx_names, function(x) tx_anno[x]$GeneSymbol)]
all_long_CN_calls_dt[,tx_starts := vector("list", nrow(all_long_CN_calls_dt))]
all_long_CN_calls_dt[,tx_starts:= tx_start_by_cnv[varID]]

all_long_CN_calls_dt[, gene_start := mapply(function(s, g) tapply(s, g, min), tx_starts, genes)]
all_long_CN_calls_dt[, genes_unique := lapply(genes, unique)  ]
all_long_CN_calls_dt[, genes_unique_sorted := mapply(function(g, s) { g[order(s[g])] }, genes_unique, gene_start)  ]
all_long_CN_calls_dt[, gene_starts_sorted := mapply(function(g, s) { s[g] }, genes_unique_sorted, gene_start)  ]

# gs_to_ensg = tx_anno[, .(ENSG=list(unique(gene))), by="GeneSymbol"]
# gs_to_ensg[,n:=elementNROWS(ENSG), by="GeneSymbol"]
# setkey(gs_to_ensg, "GeneSymbol")
# there are about 50 genes with two different ENSG IDs - we ignore all but the first one
gs_to_ensg = tx_anno[, .(ENSG=unique(gene)[1]), by="GeneSymbol"]
gs_to_ensg[,n:=elementNROWS(ENSG), by="GeneSymbol"]
setkey(gs_to_ensg, "GeneSymbol")

all_long_CN_calls_dt[, EnsemblGene := vector("list", nrow(all_long_CN_calls_dt))]
all_long_CN_calls_dt[, EnsemblGene := lapply(genes_unique_sorted, function(g) unlist(gs_to_ensg[g]$ENSG))]

# Expand to tall-skinny format (i.e. melt list entries)
gcounts = elementNROWS(all_long_CN_calls_dt$genes_unique_sorted)

CN_calls_annotated = with(all_long_CN_calls_dt, data.table(sampleID=rep(sample, gcounts), varID=rep(varID, gcounts), chrom=rep(chrom, gcounts), start=rep(loc.start, gcounts), end=rep(loc.end, gcounts), seg.mean=rep(seg.mean, gcounts), call=rep(call, gcounts), gene = unlist(genes_unique_sorted), gene_start=unlist(gene_starts_sorted), ensgene = unlist(EnsemblGene)   ) )

gene_tx_type = tx_anno[, .(TxType=paste(unique(TxType), collapse=",")), by=GeneSymbol]
classify_TxType <- function(x) {
  ifelse(grepl(",", x), ifelse(grepl("protein_coding", x), "protein_coding", "other"),
               x)
}
gene_tx_type = gene_tx_type[, TxType_Short := classify_TxType(TxType)]
setkey(gene_tx_type, GeneSymbol)

CN_calls_annotated[, TxType:= gene_tx_type[gene]$TxType_Short]

gene_by_sample_and_state = dcast.data.table(CN_calls_annotated, chrom+gene_start+gene+TxType ~ sampleID, value.var = "call", fun.aggregate = function(x) paste(x, collapse=","))
```

Genes in affected samples have been stored in the files: 

*Long_CN_calls_all_samples_with_genes.txt*

*Gene_status_by_sample.txt*

```{r}
# simplify table and convert lists to character string for export
all_long_CN_calls_for_export = all_long_CN_calls_dt[,.(varID, chrom, loc.start, loc.end, num.mark, seg.mean, sample, call, genes = unlist(lapply(genes_unique_sorted, paste, collapse=",")) )]
all_long_CN_calls_for_export = all_long_CN_calls_for_export[naturalorder(all_long_CN_calls_for_export$chrom)]

write.table(all_long_CN_calls_for_export, file=file.path(result_folder,"Long_CN_calls_all_samples_with_genes.txt"), sep="\t", row.names=F, quote=F)

write.table(gene_by_sample_and_state, file=file.path(result_folder, "Gene_status_by_sample.txt"), sep="\t", row.names=F, quote=F)
```

```{r}
save(all_long_CN_calls_dt, CN_calls_annotated, file=file.path(result_folder, "CN_calls.Rdata") )
```
